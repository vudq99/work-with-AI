import { readdirSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import { defineNuxtModule, createResolver, useLogger, addTemplate, findPath, addComponent } from '@nuxt/kit';
import { parseSync } from '@oxc-parser/wasm';

const UTILS = `import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
`;

const module = defineNuxtModule({
  meta: {
    name: "shadcn",
    configKey: "shadcn"
  },
  defaults: {
    prefix: "Ui",
    componentDir: "./components/ui"
  },
  async setup({ prefix, componentDir }, nuxt) {
    const COMPONENT_DIR_PATH = componentDir;
    const ROOT_DIR_PATH = nuxt.options.rootDir;
    const UTILS_ALIAS = "@/lib/utils";
    const { resolve, resolvePath } = createResolver(ROOT_DIR_PATH);
    const logger = useLogger("shadcn-nuxt");
    const utilsTemplate = addTemplate({
      filename: "shadcn-nuxt/utils.ts",
      getContents: () => UTILS,
      write: true
    });
    nuxt.options.alias = { [UTILS_ALIAS]: utilsTemplate.dst, ...nuxt.options.alias };
    const isRootUtilsExists = await findPath("./lib/utils.ts", { cwd: ROOT_DIR_PATH });
    if (isRootUtilsExists)
      logger.warn("[shadcn-nuxt] `lib/utils.ts` is auto generated by the module and can be safely removed.");
    const componentsPath = resolve(COMPONENT_DIR_PATH);
    nuxt.hook("components:dirs", (dirs) => {
      dirs.unshift({
        path: componentsPath,
        extensions: []
      });
    });
    try {
      readdirSync(resolve(COMPONENT_DIR_PATH)).forEach(async (dir) => {
        try {
          const filePath = await resolvePath(join(COMPONENT_DIR_PATH, dir, "index"), { extensions: [".ts", ".js"] });
          const content = readFileSync(filePath, { encoding: "utf8" });
          const ast = parseSync(content, {
            sourceType: "module",
            sourceFilename: filePath
          });
          const exportedKeys = ast.program.body.filter((node) => node.type === "ExportNamedDeclaration").flatMap((node) => node.specifiers.map((specifier) => specifier.exported.name)).filter((key) => /^[A-Z]/.test(key));
          exportedKeys.forEach((key) => {
            addComponent({
              name: `${prefix}${key}`,
              // name of the component to be used in vue templates
              export: key,
              // (optional) if the component is a named (rather than default) export
              filePath: resolve(filePath),
              priority: 1
            });
          });
        } catch (err) {
          if (err instanceof Error)
            console.warn("Module error: ", err.message);
        }
      });
    } catch (err) {
      if (err instanceof Error)
        console.warn(err.message);
    }
  }
});

export { module as default };
